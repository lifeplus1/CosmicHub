#!/usr/bin/env node
/**
 * Env Sync Utility
 *
 * Goals:
 * - Frontend apps: receive ONLY VITE_* variables (public), including Firebase client config.
 * - Backend and servers: receive ONLY non-VITE variables (server-only), including Firebase Admin creds, API keys, DB, etc.
 * - Optional root overrides: .env.server and .env.production.server can provide secret server-only values.
 * - Remove redundant env files like .env.local/.env.development to reduce confusion.
 */
import fs from 'fs';
import path from 'path';

const repoRoot = process.cwd();
const apps = ['apps/astro', 'apps/healwave'];
const servers = ['backend', 'ephemeris_server'];

/** Parse simple .env files (KEY=VALUE, # comments, ignores blank lines). */
function parseEnvFile(filePath) {
  const vars = {};
  if (!fs.existsSync(filePath)) return vars;
  const text = fs.readFileSync(filePath, 'utf8');
  for (const rawLine of text.split(/\r?\n/)) {
    const line = rawLine.trim();
    if (!line || line.startsWith('#')) continue;
    const eq = line.indexOf('=');
    if (eq === -1) continue;
    const key = line.slice(0, eq).trim();
    let val = line.slice(eq + 1).trim();
    // strip surrounding quotes if present
    if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
      val = val.slice(1, -1);
    }
    vars[key] = val;
  }
  return vars;
}

/** Serialize env map to file content with sorted keys and a header. */
function serializeEnv(vars, header) {
  const keys = Object.keys(vars).sort();
  const lines = [
    `# ${header}`,
    '# This file is autogenerated by scripts/sync-env.mjs â€” do not edit directly.',
    '# Source: root .env files',
    '',
  ];
  for (const k of keys) {
    lines.push(`${k}=${vars[k]}`);
  }
  lines.push('');
  return lines.join('\n');
}

/** Filter only public Vite variables (VITE_*) for frontend consumption. */
function pickVitePublic(env) {
  const out = {};
  for (const [k, v] of Object.entries(env)) {
    if (k.startsWith('VITE_')) out[k] = v;
  }
  // Back-compat: ensure VITE_BACKEND_URL mirrors VITE_API_URL if missing
  if (!out.VITE_BACKEND_URL && out.VITE_API_URL) {
    out.VITE_BACKEND_URL = out.VITE_API_URL;
  }
  return out;
}

/** Filter only server-only variables (non-VITE_). */
function pickServerOnly(env) {
  const out = {};
  for (const [k, v] of Object.entries(env)) {
    if (!k.startsWith('VITE_')) out[k] = v;
  }
  return out;
}

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function writeIfChanged(filePath, content) {
  if (fs.existsSync(filePath)) {
    const current = fs.readFileSync(filePath, 'utf8');
    if (current === content) return false;
  }
  fs.writeFileSync(filePath, content, 'utf8');
  return true;
}

function syncForMode(mode) {
  const isProd = mode === 'production';
  // Frontend source files
  const srcFilePublic = path.join(repoRoot, isProd ? '.env.production' : '.env');
  const srcEnvPublic = parseEnvFile(srcFilePublic);
  const publicVars = pickVitePublic(srcEnvPublic);

  // Server source files (merge base + server override if present)
  const srcFileServerBase = path.join(repoRoot, isProd ? '.env.production' : '.env');
  const srcFileServerOverride = path.join(repoRoot, isProd ? '.env.production.server' : '.env.server');
  const baseServerEnv = parseEnvFile(srcFileServerBase);
  const overrideServerEnv = parseEnvFile(srcFileServerOverride);
  const mergedServerEnv = { ...pickServerOnly(baseServerEnv), ...pickServerOnly(overrideServerEnv) };

  const header = mode === 'production' ? 'Production env (synced from root/.env.production)'
                                       : 'Development env (synced from root/.env)';

  for (const app of apps) {
    const appDir = path.join(repoRoot, app);
    const targetFile = path.join(appDir, mode === 'production' ? '.env.production' : '.env');
    ensureDir(appDir);
    const wrote = writeIfChanged(targetFile, serializeEnv(publicVars, header));
    if (wrote) console.log(`Updated ${path.relative(repoRoot, targetFile)}`);
  }

  // Sync server-only envs to servers
  const serverHeader = isProd
    ? 'Production server env (synced from root/.env.production[.server])'
    : 'Development server env (synced from root/.env[.server])';
  for (const srv of servers) {
    const srvDir = path.join(repoRoot, srv);
    ensureDir(srvDir);
    const targetFile = path.join(srvDir, isProd ? '.env.production.server' : '.env');
    // Optionally filter per-server secrets (avoid copying Firebase creds to ephemeris_server)
    let serverVars = { ...mergedServerEnv };
    if (srv === 'ephemeris_server') {
      serverVars = Object.fromEntries(Object.entries(serverVars).filter(([k]) => !k.startsWith('FIREBASE_')));
    }
    const wrote = writeIfChanged(targetFile, serializeEnv(serverVars, serverHeader));
    if (wrote) console.log(`Updated ${path.relative(repoRoot, targetFile)}`);
  }
}

function removeRedundant(appPath) {
  // Remove deprecated files we know about (keep .env and .env.production)
  const deprecated = ['.env.local', '.env.development'];
  for (const file of deprecated) {
    const p = path.join(appPath, file);
    if (fs.existsSync(p)) {
      fs.unlinkSync(p);
      console.log(`Removed deprecated ${path.relative(repoRoot, p)}`);
    }
  }
}

// Execute
syncForMode('development');
syncForMode('production');
for (const app of apps) removeRedundant(path.join(repoRoot, app));
for (const srv of servers) removeRedundant(path.join(repoRoot, srv));

console.log('Env sync complete. Restart Vite dev server to pick up changes.');
